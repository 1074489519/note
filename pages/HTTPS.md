- 简单概述
	- http报文传输过程中是明文的，可以通过抓包的方式看到报文内容，这就暴露一个安全问题，易被劫持擅改。
	- 为了解决这个问题，就有了TLS，`https = http + TLS`
	- `TLS`
		- 安全传输层协议，用于在两个通信应用程序之间提供保密性和数据完整性，该协议由两层组成：TLS记录协议（TLS Record）和TLS握手协议（TLS Handshake）。
	- TLS利用非对成加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session Key），因此https分为两个阶段
		- 1. 通过非对称加解密确认对方身份是否合法，若合法生成会话密钥。（这一步是核心）
		  2. 报文在发送前，先用会话密钥进行对称加密，再传输。
- TLS握手 #.ol
	- **"client hello"消息：**客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。
	- **"server hello"消息：**服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。
	- **验证：**客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤： #.ol
		- 检查数字签名
		- 验证证书链 (这个概念下面会进行说明)
		- 检查证书的有效期
		- 检查证书的撤回状态 (撤回代表证书已失效)
	- **"premaster secret"字符串：**客户端向服务器发送另一个随机字符串"premaster secret (预主密钥)"，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。
	- **使用私钥：**服务器使用私钥解密"premaster secret"。
	- **生成共享密钥**：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥**KEY**。
	- **客户端就绪：**客户端发送经过共享密钥**KEY**加密过的"finished"信号。
	- **服务器就绪：**服务器发送经过共享密钥**KEY**加密过的"finished"信号。
	- **达成安全通信：**握手完成，双方使用对称加密进行安全通信。
- CA证书
	- 第一步讲到CA证书，假如没有证书验证这一环节，那么公钥在传输过程极有可能被中间人拦截，来个狸猫换太子，将服务端的公钥换成它自己的公钥，返回给客户端，那么一来，就完全起不到加密的作用了，也就是中间人攻击
	- 所以就需要一个验证的机制，保证公钥是来自服务端的，没有被擅改的，CA证书就出场了
	- CA证书，是由CA机构办法的一个凭证，里面关键的信息有：签名算法、签名hash算法、颁发者、有效期、公钥、指纹，这两个算法就表示对称阶段和非对称阶段采用的算法，公钥就是服务端的公钥，在申请的时候，企业需要上传公钥给CA机构，重点是这个指纹，这个指纹是由CA机构通过私钥对一段签名加密生成的
	- 所以通过验证证书是否合法，就知道公钥是否被擅改，那么怎么验证合法呢
	- 自然是通过证书的指纹
	- 在浏览器和个人PC中，都预装了顶级的CA机构证书和公钥，所以浏览器获得到证书后，通过内置的公钥对指纹进行解密得到签名，然后浏览器也根据同样的规则生成一段签名，两段签名进行比较，验证通过，那么这个证书中公钥就是可信的
	- 那么这样一来不是就可以完全避免了中间人攻击呢？
	- 毕竟顶级的CA证书是内置的，还有一种方法，们是可以用 Fiddle 对 https 进行抓包的，那 Fiddle 算不算中间人呢 ？
	- Fiddle 之所以能拦截成功是因为，我们在抓包之前，在我们自己手机安装一份来自 Fiddle 的证书，也就是客户端自己信任了第三方来源的证书，这么一来客户端自然能解析出 Fiddle 转发出来的报文啦。
	- 所以只要不随意信任第三方证书，基本上是不会发生中间人攻击的。
	-
-
- 其他参考
	- [SSL/TLS协议运行机制的概述 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
	- [segmentfault.com | 525: SSL handshake failed](https://segmentfault.com/a/1190000019976390)
	-